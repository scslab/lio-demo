\section{Overview}
\label{sec:overview}

Like other IFC systems, LIO tracks and controls the propagation of
information by associating a \emph{label} with every piece of
data.
%\footnote{
%  While LIO is polymorphic in the label model, we focus on LIO with
%  DCLabels~\cite{dclabels}, henceforth just labels. 
% }
%
A label encodes a security policy as a pair of positive boolean
formulas over \emph{principals} specifying who may read or write data.
%
For example, a review labeled \hs|"alice" \/ "bob" %% "bob"| specifies
that the review can be read by user \hs|"alice"| or \hs|"bob"|, but
may only be modified by \hs|"bob"|.
%
Indeed, such a label may be associated with \hs|"bob"|'s review, for a
paper that both \hs|"bob"| and \hs|"alice"| are reviewing.
%

Our library associates labels with various language constructs,
including references, channels, and files.
%
Moreover, we provide a type, \hs|Labeled|, which can be used to
explicitly label individual Haskell terms; since LIO is a library,
terms that are not explicitly \hs|Labeled| are associated with the
label of the current computation (described below).
%
We use such \hs|Labeled| values to protect reviews.
%

Labels on objects are partially ordered according to a {\em can flow
  to} relation $\canflowto$: for any labels $L_A$ and $L_B$, if $L_A
  \canflowto L_B$ then the policy encoded by $L_A$ is \emph{upheld}
  by that of $L_B$.
%
For example, data labeled $L_A =$ \hs|"alice" \/ "bob" %% "bob"| can
be written to a file labeled $L_B =$ \hs|"bob" %% "bob"| since $L_B$
preserves the secrecy of $L_A$.
%
In fact, $L_B$ is \emph{more} restrictive, as only
\hs|"bob"|---not both \hs|"alice"| and \hs|"bob"|---can read the file.
%
Conversely, $L_B \not\canflowto L_A$, and thus data labeled $L_B$
cannot be written to an object labeled $L_A$.

It is precisely this relation that LIO uses to restrict the
effects of computations executing in the \hs|LIO| monad.
%
The \hs|LIO| monad encapsulates a computation that executes in Haskell's
``default'' \hs|IO| monad, associating
with it a label---the
\emph{current label}---that tracks the sensitivity of all the data
that the computation has observed.
%
To illustrate the role of the current label, consider the code below
that reads \hs|"bob"|'s private review and tries to leak it into
\hs|"alice"|'s reference.
\vspace*{-1.0em}
\begin{minted}[frame=lines, mathescape]{haskell}
-- Current label: public == True %% True
bobReview <- readFile "/reviews/bob/5.txt"
-- Current label: "bob" %% True
writeLIORef aliceRef bobReview
-- Fail: "bob" %% True $\not\canflowto$ "alice" %% "alice"
\end{minted}
\vspace*{-0.4em}
%
Here, the current label is first raised by \hs|readFile|, reflexing
that \hs|"bob"|'s sensitive information was incorporated into the
context.
%
Importantly, however, this label is also used to subsequently restrict
writes; in this case, the \hs|writeLIORef| action throws an
exception, since the write is unsafe.

In general, IFC enforcement in LIO follows this approach of exposing
functions (e.g., \hs|writeLIORef|), which inspect the current label
and the label of object they are about to read/write as to uphold the
\emph{can flow to} relation.
%
We solely rely on Haskell's monad support as a way to define a
sublanguage for which we can enforce IFC.
%
And, by ensuring that untrusted code is written in this sublanguage, i.e.,
it cannot execute arbitrary \hs|IO| actions, we can incorporate
arbitrary untrusted code to compute on sensitive data.
%
For example, as we will show, our conference review system can
incorporate code provided by users of the system without fear of
leaking reviews or reviewer identities, all while allowing the code to
interact with the external world (e.g., using the HTTP client).


\section{Automatic data labeling}

LIO guarantees that code executing in the \hs|LIO| monad cannot
violate the confidentiality and integrity restrictions imposed by
labels.
%
Thus the untrusted parts of an application can be implement almost
carelessly---LIO ensures that bugs do not escalate to vulnerabilities.
%
Unfortunately, the trusted part of an application, that of assigning
appropriate labels to data, is still a challenge.
%
And, while using a simple label model such as DCLabels can address
certain pitfalls, a non-expert approach to setting labels is clearly
desirable.

In the context of web applications, we present a declarative policy
language, similar to that used in Hails~\cite{hails}, which makes this
task more tractable.
%
Specifically, since data models for web applications are typically
specified in a declarative form, and, in many applications, the
authoritative source for who should access the data resides in the
data itself, our policy language leverages and extends these ideas
directly. 
%
In our system, labels are specified as read and write clauses
alongside the data model, and in terms of it.

Consider the definition of the \hs|Review| data type used in our
conference review system:
\vspace*{-1.0em}
\begin{minted}[frame=lines]{haskell}
data Review = Review { _id   :: ID
                     , paper :: ID
                     , owner :: User, ... }
\end{minted}
\vspace*{-0.4em}
To associate a label with a review we can leverage the 
information present in the record type.
%
Specifically, we can specify that the only user allowed to modify such
a review is the owner of the review, and that the only users allowed
to read such a review are the owner and other reviewers of the same
paper.
%
The latter declaration requires that we perform a lookup, using the
paper id of the current review, to find the other reviewers.
%
Below is the policy code specifying this.
%
\vspace*{-1.0em}
\begin{minted}[frame=lines]{haskell}
policy :: HailsDB m => Review -> m DCLabel
policy rev = do
  let me = owner rev
  reviewers <- findReviewersOf $ paper rev
  makePolicy $ do readers ==> me \/ reviewers
                  writers ==> me
\end{minted}
\vspace*{-0.4em}
%
This function is self-explanatory; we only remark that the function
takes a \hs|Review| and returns a \hs|DCLabel| in a monad \hs|m| that
allows code to perform database actions (in this case the
\hs|findReviewersOf| action), a change from the original pure policies
of Hails.
%

While some care must be taken to ensure that the specified policy is
correct, the extend of understanding a security policy in such
LIO/Hails applications is limited to such functions.
%
It is these policy functions that our database system uses to label
reviews when a fetch, insert, or update is performed.
%
Indeed, as we will see in the demo, the core of the conference review
system does not manipulate labels; high-level APIs leveraging this
automatic labeling approach make most of the IFC details transparent.


